# -*- coding: utf-8 -*-
"""k_means.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1QZ-7BS7GfOKtCZQpXAUQNxVOQN_1cLix

# Cluster K-means

### Feito por: Jonathas Luis de Sousa
### GCC128-Inteligência Artificial
### Turma 14A

## Carregamento e tratamento do Dataset

Nesta seção se encontra a importação das bibliotecas, inclusive o dataset Iris, direto da biblioteca sklearn.

Além disso, é mostrado alguns metadados do dataset, que alguns auxiliará nos parâmetros do kmeans.

Além do mais, o dataset é convertido em uma etrutura de dados mais simples de ser trabalhada, no caso as listas.

Bibliotecas / Pacotes utilizadas:
  - **sklearn -> datasets:** pacote em que se encontra datasets para estudo de ML;
  - **pandas:** biblioteca de manipulação e análise de dados;
  - **matplotlib -> pyplot:** biblioteca para a vizualização gráfica dos dados;
  - **scipy.spatial -> distance:** biblioteca com funções de calculos de distâncias;
  - **random:** módulo que implementa geradores de números pseudoaleatórios;
  - **numpy:** pacote com uma grande coleção de funções matemáticas
"""

from sklearn import datasets
import pandas as pd
from matplotlib import pyplot as plt
from scipy.spatial import distance
import random
import numpy as np

# carregamento do dataset iris do sklean
iris = datasets.load_iris()
iris_df=pd.DataFrame(iris.data)
iris_df["classe"] = iris.target
iris_df.columns=['sepal_len', 'sepal_wid', 'petal_len', 'petal_wid','classe']

iris_df.tail()

#informações sobre dataFrame
print(iris_df.shape, '\n')
print(iris_df.columns,'\n')
print(iris_df.dtypes)

# estatisticas dos dados
iris_df.describe()

#Transformaçao do DataFrame em uma lista, sem a coluna "classe"
dadosIris = iris_df.drop("classe",axis=1).values.tolist()

"""## Parâmetros

Nesta seção, encontra-se os parâmetros necessários para a execução do algoritmo kmeans, sendo:
- **k:** o numero de clusters;
- **quantidadeColunas:** quantidade de colunas no dataset;
- **limiteSuperior:** lista com valores próximos ao maior valor de cada coluna do dataset, importante para a geração dos centróides;
- **limiteInferior:** lista com valores próximos ao menor valor de cada coluna do dataset, importante para a geração dos centróides;
- **numeroMaximoIteracoes:** numero máximo de vezes em que o loop do algoritmo executará;
- **limiteConvergencia:** valor mínimo das distâncias entre os centróides novos e os antigos, ou seja, a mudança mínima na posição dos centóides.
"""

k = 3
quantidadeColunas = 4
limiteSuperior = [8,5,7,3]
limiteInferior = [4,2,1,0]
numeroMaximoIteracoes = 100
limiteConvergencia = 0.02

"""## Algoritmo

Algoritmo kmeans e funções auxiliares

### Funções Auxiliares
"""

# cria uma lista com os centroides em posições aleatorias, repeitando os limites dos pontos em cada coluna -> Lista: centroides X coordenadas
def inicializaCentroides():
   centroides = np.random.uniform(limiteInferior,limiteSuperior, (k,quantidadeColunas))
   return np.round(centroides, 2).tolist()

#calcula a distancia euclidiana entre dois pontos, considerando todas as colunas / dimensões
def distanciaEuclidiana(p1,p2):
  return distance.euclidean(p1,p2)

# calcula o ponto médio entre vários pontos -> retorna um ponto que está à mesma distância entre os outros pontos
def calculaPontoMedio(pontos):
  if len(pontos) == 0:
      return [0.0] * quantidadeColunas  # Retorna o ponto na Origem

  numDimensoes = len(pontos[0])  # Obtém o número de dimensões dos pontos
  pontoMedio = [0.0] * numDimensoes  # Inicializa o ponto médio com zeros

  for ponto in pontos:
      for dimensao in range(numDimensoes):
          pontoMedio[dimensao] += ponto[dimensao]

  for dimensao in range(numDimensoes):
      pontoMedio[dimensao] /= len(pontos)

  return pontoMedio

# recalcula a posição dos centróides de acordo com o ponto médio de cada cluster
def recalculaPosicaoCentroides(cluster,centroides):
  centroidesAtualizados = []
  for c in centroides:
    pontos = cluster[centroides.index(c)]
    if len(pontos)!= 0:
      novoCentroide = calculaPontoMedio(pontos)
    else:
      novoCentroide = c # caso não tenha pontos no cluster o centroide não muda de posição
    centroidesAtualizados.append(novoCentroide)
  return centroidesAtualizados

# verifica se houve uma mudança significativa na posição dos centroides
def verificaConvergencia(pontosAnteriores, pontosAtuais):
  for pontoAnterior, pontoAtual in zip(pontosAnteriores, pontosAtuais):
    if distanciaEuclidiana(pontoAnterior, pontoAtual) > limiteConvergencia:
      return True
  return False

#Dado um ponto, retorna a posição, na lista de centroides, do centroide mais próximo do ponto
def centroideMaisProximo(ponto,centroides):
  centroideMaisProximo = -1
  menorDistancia = 999999

  for i in range(0,k):
    distancia = distanciaEuclidiana(ponto,centroides[i])
    if distancia < menorDistancia:
      menorDistancia = distancia
      centroideMaisProximo = i
  return centroideMaisProximo

#cria um cluster vazio, uma lista com k listas vazias
def inicializaClustersVazios():
  cluster = []
  for i in range(k):
    cluster.append(list())
  return cluster

"""### K-Means"""

def kMeans(centroides,listaDePontos):
  clusters = [] # Matriz Tri-dimensional -> cluster x itens x coordenadas
  contador = 0 # conta as iterações
  centroidesAtualizados = []

  # enquanto o numero maximo de iterações não for atingido OU enquanto os centroides não convergiram
  while contador < numeroMaximoIteracoes  and (contador == 0 or verificaConvergencia(centroides,centroidesAtualizados)):
    clusters = inicializaClustersVazios()
    if contador != 0:
      centroides = centroidesAtualizados
    # para cada ponto, inseri-lo no cluster referente ao centroide mais proximo
    for ponto in listaDePontos:
      pos = centroideMaisProximo(ponto,centroides)
      clusters[pos].append(ponto)
    contador += 1
    # Atualiza a posição dos centroides
    centroidesAtualizados = recalculaPosicaoCentroides(clusters,centroides)

  return clusters, centroides

centroides = inicializaCentroides()
centroides

clusterizacaoIris,centroides = kMeans(centroides,dadosIris)

"""## Visualização"""

def getListThePosition(pos,data):
  lista = list()
  for i in data:
    lista.append(i[pos])
  return lista

def plotResult(position1, position2,xLabel,yLabel,defaultTitle,legendPosition):
  plt.figure(figsize=(12, 5))
  plt.subplot(121)

  plt.scatter(getListThePosition(position1,clusterizacaoIris[0]), getListThePosition(position2,clusterizacaoIris[0]), s = 50, c = 'green', label = '0')
  plt.scatter(getListThePosition(position1,clusterizacaoIris[1]), getListThePosition(position2,clusterizacaoIris[1]), s = 50, c = 'orange', label = '1')
  plt.scatter(getListThePosition(position1,clusterizacaoIris[2]), getListThePosition(position2,clusterizacaoIris[2]), s = 50, c = 'blue', label = '2')
  plt.scatter(getListThePosition(position1,centroides), getListThePosition(position2,centroides), s = 50, c = 'red', label = 'Centroids',  marker='^')
  plt.xlabel(xLabel)
  plt.ylabel(yLabel)
  plt.title(defaultTitle + ' - with Kmeans')
  plt.legend(loc=legendPosition)

  plt.subplot(122)
  X = iris.data
  y = iris.target

  setosa = X[y == 0]
  versicolor = X[y == 1]
  virginica = X[y == 2]

  plt.scatter(virginica[:, position1], virginica[:, position2], label='Virginica',  s = 50, c = 'green')
  plt.scatter(versicolor[:, position1], versicolor[:, position2], label='Versicolor', s = 50, c = 'orange')
  plt.scatter(setosa[:, position1], setosa[:, position2], label='Setosa', s = 50, c = 'blue')

  plt.xlabel(xLabel)
  plt.ylabel(yLabel)
  plt.title(defaultTitle)
  plt.legend(loc=legendPosition)

  plt.show()

"""### Sepal Lenght vs Sepal Width"""

plotResult(0,1,'Sepal Lenght (cm)','Sepal Width (cm)','Sepal Lenght vs Sepal Width','upper right')

"""### Sepal Lenght vs Petal Width"""

plotResult(0,3,'Sepal Length (cm)','Petal Width (cm)','Sepal Length vs Petal Width','lower right')

"""### Sepal Width vs Petal Width"""

plotResult(1,3,'Sepal Width (cm)','Petal Width (cm)','Sepal Width vs Sepal Width','center right')

"""### Petal Lenght vs Sepal Lenght"""

plotResult(2,0,'Petal Length (cm)','Sepal Lenght (cm)','Petal Length vs Sepal Lenght','lower right')

"""### Petal Length vs Sepal Width"""

plotResult(2,1,'Petal Length (cm)','Sepal Width (cm)','Petal Length vs Sepal Width','upper right')

"""### Petal Lenght vs Petal Width"""

plotResult(2,3,'Petal Length (cm)','Petal Width (cm)','Petal Length vs Petal Width','lower right')